// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: vehicle.sql

package database

import (
	"context"
	"database/sql"
	"time"
)

const checkoutVehicle = `-- name: CheckoutVehicle :exec
UPDATE vehicle 
SET check_out_time = $2, 
    is_checked_out = $3
WHERE id = $1
`

type CheckoutVehicleParams struct {
	ID           int32
	CheckOutTime sql.NullTime
	IsCheckedOut sql.NullBool
}

func (q *Queries) CheckoutVehicle(ctx context.Context, arg CheckoutVehicleParams) error {
	_, err := q.db.ExecContext(ctx, checkoutVehicle, arg.ID, arg.CheckOutTime, arg.IsCheckedOut)
	return err
}

const createDriver = `-- name: CreateDriver :one
INSERT INTO driver (fullname, phone_number, email, created_at, updated_at)
VALUES($1, $2, $3, $4, $5) RETURNING id
`

type CreateDriverParams struct {
	Fullname    string
	PhoneNumber string
	Email       sql.NullString
	CreatedAt   time.Time
	UpdatedAt   time.Time
}

func (q *Queries) CreateDriver(ctx context.Context, arg CreateDriverParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, createDriver,
		arg.Fullname,
		arg.PhoneNumber,
		arg.Email,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const createVehicle = `-- name: CreateVehicle :execresult
INSERT INTO vehicle(driver_id, license_number, model, security_notes, parking_id, service_id, is_checked_out, check_in_time, created_at, updated_at)
VALUES($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
`

type CreateVehicleParams struct {
	DriverID      int32
	LicenseNumber string
	Model         sql.NullString
	SecurityNotes sql.NullString
	ParkingID     int32
	ServiceID     int32
	IsCheckedOut  sql.NullBool
	CheckInTime   sql.NullTime
	CreatedAt     time.Time
	UpdatedAt     time.Time
}

func (q *Queries) CreateVehicle(ctx context.Context, arg CreateVehicleParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createVehicle,
		arg.DriverID,
		arg.LicenseNumber,
		arg.Model,
		arg.SecurityNotes,
		arg.ParkingID,
		arg.ServiceID,
		arg.IsCheckedOut,
		arg.CheckInTime,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
}

const deleteDriverById = `-- name: DeleteDriverById :exec
DELETE FROM driver WHERE id = $1
`

func (q *Queries) DeleteDriverById(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteDriverById, id)
	return err
}

const deleteVehicleById = `-- name: DeleteVehicleById :exec
DELETE FROM vehicle WHERE id = $1
`

func (q *Queries) DeleteVehicleById(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteVehicleById, id)
	return err
}

const getDriverById = `-- name: GetDriverById :one
SELECT id, fullname, phone_number, email, created_at, updated_at FROM driver WHERE id = $1
`

func (q *Queries) GetDriverById(ctx context.Context, id int32) (Driver, error) {
	row := q.db.QueryRowContext(ctx, getDriverById, id)
	var i Driver
	err := row.Scan(
		&i.ID,
		&i.Fullname,
		&i.PhoneNumber,
		&i.Email,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getDriverByName = `-- name: GetDriverByName :one
SELECT id, fullname, phone_number, email, created_at, updated_at FROM driver WHERE fullname LIKE $1
`

func (q *Queries) GetDriverByName(ctx context.Context, fullname string) (Driver, error) {
	row := q.db.QueryRowContext(ctx, getDriverByName, fullname)
	var i Driver
	err := row.Scan(
		&i.ID,
		&i.Fullname,
		&i.PhoneNumber,
		&i.Email,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getVehicleById = `-- name: GetVehicleById :one
SELECT vehicle.id, driver_id, license_number, model, security_notes, parking_id, service_id, is_checked_out, check_in_time, check_out_time, vehicle.created_at, vehicle.updated_at, driver.id, fullname, phone_number, email, driver.created_at, driver.updated_at FROM vehicle JOIN driver ON vehicle.driver_id = driver.id  WHERE vehicle.id = $1
`

type GetVehicleByIdRow struct {
	ID            int32
	DriverID      int32
	LicenseNumber string
	Model         sql.NullString
	SecurityNotes sql.NullString
	ParkingID     int32
	ServiceID     int32
	IsCheckedOut  sql.NullBool
	CheckInTime   sql.NullTime
	CheckOutTime  sql.NullTime
	CreatedAt     time.Time
	UpdatedAt     time.Time
	ID_2          int32
	Fullname      string
	PhoneNumber   string
	Email         sql.NullString
	CreatedAt_2   time.Time
	UpdatedAt_2   time.Time
}

func (q *Queries) GetVehicleById(ctx context.Context, id int32) (GetVehicleByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getVehicleById, id)
	var i GetVehicleByIdRow
	err := row.Scan(
		&i.ID,
		&i.DriverID,
		&i.LicenseNumber,
		&i.Model,
		&i.SecurityNotes,
		&i.ParkingID,
		&i.ServiceID,
		&i.IsCheckedOut,
		&i.CheckInTime,
		&i.CheckOutTime,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ID_2,
		&i.Fullname,
		&i.PhoneNumber,
		&i.Email,
		&i.CreatedAt_2,
		&i.UpdatedAt_2,
	)
	return i, err
}

const getVehiclesByDriver = `-- name: GetVehiclesByDriver :many
SELECT vehicle.id, driver_id, license_number, model, security_notes, parking_id, service_id, is_checked_out, check_in_time, check_out_time, vehicle.created_at, vehicle.updated_at, driver.id, fullname, phone_number, email, driver.created_at, driver.updated_at FROM vehicle JOIN driver ON vehicle.driver_id = driver.id  WHERE vehicle.driver_id = $1
`

type GetVehiclesByDriverRow struct {
	ID            int32
	DriverID      int32
	LicenseNumber string
	Model         sql.NullString
	SecurityNotes sql.NullString
	ParkingID     int32
	ServiceID     int32
	IsCheckedOut  sql.NullBool
	CheckInTime   sql.NullTime
	CheckOutTime  sql.NullTime
	CreatedAt     time.Time
	UpdatedAt     time.Time
	ID_2          int32
	Fullname      string
	PhoneNumber   string
	Email         sql.NullString
	CreatedAt_2   time.Time
	UpdatedAt_2   time.Time
}

func (q *Queries) GetVehiclesByDriver(ctx context.Context, driverID int32) ([]GetVehiclesByDriverRow, error) {
	rows, err := q.db.QueryContext(ctx, getVehiclesByDriver, driverID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetVehiclesByDriverRow
	for rows.Next() {
		var i GetVehiclesByDriverRow
		if err := rows.Scan(
			&i.ID,
			&i.DriverID,
			&i.LicenseNumber,
			&i.Model,
			&i.SecurityNotes,
			&i.ParkingID,
			&i.ServiceID,
			&i.IsCheckedOut,
			&i.CheckInTime,
			&i.CheckOutTime,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ID_2,
			&i.Fullname,
			&i.PhoneNumber,
			&i.Email,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVehiclesByLicense = `-- name: GetVehiclesByLicense :many
SELECT vehicle.id, driver_id, license_number, model, security_notes, parking_id, service_id, is_checked_out, check_in_time, check_out_time, vehicle.created_at, vehicle.updated_at, driver.id, fullname, phone_number, email, driver.created_at, driver.updated_at FROM vehicle JOIN driver ON vehicle.driver_id = driver.id  WHERE vehicle.license_number = $1
`

type GetVehiclesByLicenseRow struct {
	ID            int32
	DriverID      int32
	LicenseNumber string
	Model         sql.NullString
	SecurityNotes sql.NullString
	ParkingID     int32
	ServiceID     int32
	IsCheckedOut  sql.NullBool
	CheckInTime   sql.NullTime
	CheckOutTime  sql.NullTime
	CreatedAt     time.Time
	UpdatedAt     time.Time
	ID_2          int32
	Fullname      string
	PhoneNumber   string
	Email         sql.NullString
	CreatedAt_2   time.Time
	UpdatedAt_2   time.Time
}

func (q *Queries) GetVehiclesByLicense(ctx context.Context, licenseNumber string) ([]GetVehiclesByLicenseRow, error) {
	rows, err := q.db.QueryContext(ctx, getVehiclesByLicense, licenseNumber)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetVehiclesByLicenseRow
	for rows.Next() {
		var i GetVehiclesByLicenseRow
		if err := rows.Scan(
			&i.ID,
			&i.DriverID,
			&i.LicenseNumber,
			&i.Model,
			&i.SecurityNotes,
			&i.ParkingID,
			&i.ServiceID,
			&i.IsCheckedOut,
			&i.CheckInTime,
			&i.CheckOutTime,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ID_2,
			&i.Fullname,
			&i.PhoneNumber,
			&i.Email,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVehiclesByParking = `-- name: GetVehiclesByParking :many
SELECT vehicle.id, driver_id, license_number, model, security_notes, parking_id, service_id, is_checked_out, check_in_time, check_out_time, vehicle.created_at, vehicle.updated_at, driver.id, fullname, phone_number, email, driver.created_at, driver.updated_at FROM vehicle JOIN driver ON vehicle.driver_id = driver.id  WHERE vehicle.parking_id = $1
`

type GetVehiclesByParkingRow struct {
	ID            int32
	DriverID      int32
	LicenseNumber string
	Model         sql.NullString
	SecurityNotes sql.NullString
	ParkingID     int32
	ServiceID     int32
	IsCheckedOut  sql.NullBool
	CheckInTime   sql.NullTime
	CheckOutTime  sql.NullTime
	CreatedAt     time.Time
	UpdatedAt     time.Time
	ID_2          int32
	Fullname      string
	PhoneNumber   string
	Email         sql.NullString
	CreatedAt_2   time.Time
	UpdatedAt_2   time.Time
}

func (q *Queries) GetVehiclesByParking(ctx context.Context, parkingID int32) ([]GetVehiclesByParkingRow, error) {
	rows, err := q.db.QueryContext(ctx, getVehiclesByParking, parkingID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetVehiclesByParkingRow
	for rows.Next() {
		var i GetVehiclesByParkingRow
		if err := rows.Scan(
			&i.ID,
			&i.DriverID,
			&i.LicenseNumber,
			&i.Model,
			&i.SecurityNotes,
			&i.ParkingID,
			&i.ServiceID,
			&i.IsCheckedOut,
			&i.CheckInTime,
			&i.CheckOutTime,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ID_2,
			&i.Fullname,
			&i.PhoneNumber,
			&i.Email,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVehiclesByService = `-- name: GetVehiclesByService :many
SELECT vehicle.id, driver_id, license_number, model, security_notes, parking_id, service_id, is_checked_out, check_in_time, check_out_time, vehicle.created_at, vehicle.updated_at, driver.id, fullname, phone_number, email, driver.created_at, driver.updated_at FROM vehicle JOIN driver ON vehicle.driver_id = driver.id  WHERE vehicle.service_id = $1
`

type GetVehiclesByServiceRow struct {
	ID            int32
	DriverID      int32
	LicenseNumber string
	Model         sql.NullString
	SecurityNotes sql.NullString
	ParkingID     int32
	ServiceID     int32
	IsCheckedOut  sql.NullBool
	CheckInTime   sql.NullTime
	CheckOutTime  sql.NullTime
	CreatedAt     time.Time
	UpdatedAt     time.Time
	ID_2          int32
	Fullname      string
	PhoneNumber   string
	Email         sql.NullString
	CreatedAt_2   time.Time
	UpdatedAt_2   time.Time
}

func (q *Queries) GetVehiclesByService(ctx context.Context, serviceID int32) ([]GetVehiclesByServiceRow, error) {
	rows, err := q.db.QueryContext(ctx, getVehiclesByService, serviceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetVehiclesByServiceRow
	for rows.Next() {
		var i GetVehiclesByServiceRow
		if err := rows.Scan(
			&i.ID,
			&i.DriverID,
			&i.LicenseNumber,
			&i.Model,
			&i.SecurityNotes,
			&i.ParkingID,
			&i.ServiceID,
			&i.IsCheckedOut,
			&i.CheckInTime,
			&i.CheckOutTime,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ID_2,
			&i.Fullname,
			&i.PhoneNumber,
			&i.Email,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVehiclesExisting = `-- name: GetVehiclesExisting :many
SELECT id, driver_id, license_number, model, security_notes, parking_id, service_id, is_checked_out, check_in_time, check_out_time, created_at, updated_at FROM vehicle WHERE license_number = $1 AND created_at > $2 AND created_at < $3 AND service_id = $4
`

type GetVehiclesExistingParams struct {
	LicenseNumber string
	CreatedAt     time.Time
	CreatedAt_2   time.Time
	ServiceID     int32
}

func (q *Queries) GetVehiclesExisting(ctx context.Context, arg GetVehiclesExistingParams) ([]Vehicle, error) {
	rows, err := q.db.QueryContext(ctx, getVehiclesExisting,
		arg.LicenseNumber,
		arg.CreatedAt,
		arg.CreatedAt_2,
		arg.ServiceID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Vehicle
	for rows.Next() {
		var i Vehicle
		if err := rows.Scan(
			&i.ID,
			&i.DriverID,
			&i.LicenseNumber,
			&i.Model,
			&i.SecurityNotes,
			&i.ParkingID,
			&i.ServiceID,
			&i.IsCheckedOut,
			&i.CheckInTime,
			&i.CheckOutTime,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDriver = `-- name: ListDriver :many
SELECT id, fullname, phone_number, email, created_at, updated_at FROM driver ORDER BY ID DESC
`

func (q *Queries) ListDriver(ctx context.Context) ([]Driver, error) {
	rows, err := q.db.QueryContext(ctx, listDriver)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Driver
	for rows.Next() {
		var i Driver
		if err := rows.Scan(
			&i.ID,
			&i.Fullname,
			&i.PhoneNumber,
			&i.Email,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVehicle = `-- name: ListVehicle :many
SELECT vehicle.id, driver_id, license_number, model, security_notes, parking_id, service_id, is_checked_out, check_in_time, check_out_time, vehicle.created_at, vehicle.updated_at, driver.id, fullname, phone_number, email, driver.created_at, driver.updated_at FROM vehicle JOIN driver ON vehicle.driver_id = driver.id ORDER BY vehicle.ID DESC
`

type ListVehicleRow struct {
	ID            int32
	DriverID      int32
	LicenseNumber string
	Model         sql.NullString
	SecurityNotes sql.NullString
	ParkingID     int32
	ServiceID     int32
	IsCheckedOut  sql.NullBool
	CheckInTime   sql.NullTime
	CheckOutTime  sql.NullTime
	CreatedAt     time.Time
	UpdatedAt     time.Time
	ID_2          int32
	Fullname      string
	PhoneNumber   string
	Email         sql.NullString
	CreatedAt_2   time.Time
	UpdatedAt_2   time.Time
}

func (q *Queries) ListVehicle(ctx context.Context) ([]ListVehicleRow, error) {
	rows, err := q.db.QueryContext(ctx, listVehicle)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListVehicleRow
	for rows.Next() {
		var i ListVehicleRow
		if err := rows.Scan(
			&i.ID,
			&i.DriverID,
			&i.LicenseNumber,
			&i.Model,
			&i.SecurityNotes,
			&i.ParkingID,
			&i.ServiceID,
			&i.IsCheckedOut,
			&i.CheckInTime,
			&i.CheckOutTime,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ID_2,
			&i.Fullname,
			&i.PhoneNumber,
			&i.Email,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchVehicle = `-- name: SearchVehicle :many
SELECT vehicle.id, driver_id, license_number, model, security_notes, parking_id, service_id, is_checked_out, check_in_time, check_out_time, vehicle.created_at, vehicle.updated_at, driver.id, fullname, phone_number, email, driver.created_at, driver.updated_at FROM vehicle JOIN driver ON vehicle.driver_id = driver.id WHERE vehicle.license_number LIKE '%'||$1||'%' OR driver.fullname LIKE '%'||$1||'%'  ORDER BY vehicle.created_at DESC
`

type SearchVehicleRow struct {
	ID            int32
	DriverID      int32
	LicenseNumber string
	Model         sql.NullString
	SecurityNotes sql.NullString
	ParkingID     int32
	ServiceID     int32
	IsCheckedOut  sql.NullBool
	CheckInTime   sql.NullTime
	CheckOutTime  sql.NullTime
	CreatedAt     time.Time
	UpdatedAt     time.Time
	ID_2          int32
	Fullname      string
	PhoneNumber   string
	Email         sql.NullString
	CreatedAt_2   time.Time
	UpdatedAt_2   time.Time
}

func (q *Queries) SearchVehicle(ctx context.Context, dollar_1 sql.NullString) ([]SearchVehicleRow, error) {
	rows, err := q.db.QueryContext(ctx, searchVehicle, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchVehicleRow
	for rows.Next() {
		var i SearchVehicleRow
		if err := rows.Scan(
			&i.ID,
			&i.DriverID,
			&i.LicenseNumber,
			&i.Model,
			&i.SecurityNotes,
			&i.ParkingID,
			&i.ServiceID,
			&i.IsCheckedOut,
			&i.CheckInTime,
			&i.CheckOutTime,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ID_2,
			&i.Fullname,
			&i.PhoneNumber,
			&i.Email,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateDriver = `-- name: UpdateDriver :exec
UPDATE driver 
SET fullname = $2, phone_number = $3, 
    email = $4, updated_at = $5
WHERE id = $1
`

type UpdateDriverParams struct {
	ID          int32
	Fullname    string
	PhoneNumber string
	Email       sql.NullString
	UpdatedAt   time.Time
}

func (q *Queries) UpdateDriver(ctx context.Context, arg UpdateDriverParams) error {
	_, err := q.db.ExecContext(ctx, updateDriver,
		arg.ID,
		arg.Fullname,
		arg.PhoneNumber,
		arg.Email,
		arg.UpdatedAt,
	)
	return err
}

const updateVehicle = `-- name: UpdateVehicle :exec
UPDATE vehicle 
SET driver_id = $2, license_number = $3, 
    model = $4, security_notes = $5, 
    updated_at = $6
WHERE id = $1
`

type UpdateVehicleParams struct {
	ID            int32
	DriverID      int32
	LicenseNumber string
	Model         sql.NullString
	SecurityNotes sql.NullString
	UpdatedAt     time.Time
}

func (q *Queries) UpdateVehicle(ctx context.Context, arg UpdateVehicleParams) error {
	_, err := q.db.ExecContext(ctx, updateVehicle,
		arg.ID,
		arg.DriverID,
		arg.LicenseNumber,
		arg.Model,
		arg.SecurityNotes,
		arg.UpdatedAt,
	)
	return err
}
