// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: vehicle.sql

package database

import (
	"context"
	"database/sql"
	"time"
)

const checkoutVehicle = `-- name: CheckoutVehicle :exec
UPDATE vehicle
SET check_out_time = $2,
    is_checked_out = $3,
    checked_out_by = $4
WHERE id = $1
`

type CheckoutVehicleParams struct {
	ID           int32
	CheckOutTime sql.NullTime
	IsCheckedOut sql.NullBool
	CheckedOutBy int32
}

func (q *Queries) CheckoutVehicle(ctx context.Context, arg CheckoutVehicleParams) error {
	_, err := q.db.ExecContext(ctx, checkoutVehicle,
		arg.ID,
		arg.CheckOutTime,
		arg.IsCheckedOut,
		arg.CheckedOutBy,
	)
	return err
}

const createDriver = `-- name: CreateDriver :one
INSERT INTO driver (fullname, phone_number, email, created_at, updated_at)
VALUES($1, $2, $3, $4, $5) RETURNING id
`

type CreateDriverParams struct {
	Fullname    string
	PhoneNumber string
	Email       sql.NullString
	CreatedAt   time.Time
	UpdatedAt   time.Time
}

func (q *Queries) CreateDriver(ctx context.Context, arg CreateDriverParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, createDriver,
		arg.Fullname,
		arg.PhoneNumber,
		arg.Email,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const createVehicle = `-- name: CreateVehicle :execresult
INSERT INTO vehicle(driver_id, license_number, card_number, occupants, model, security_notes, parking_id, service_id, checked_in_by, is_checked_out, check_in_time, created_at, updated_at)
VALUES($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
`

type CreateVehicleParams struct {
	DriverID      int32
	LicenseNumber string
	CardNumber    sql.NullString
	Occupants     sql.NullString
	Model         sql.NullString
	SecurityNotes sql.NullString
	ParkingID     int32
	ServiceID     int32
	CheckedInBy   int32
	IsCheckedOut  sql.NullBool
	CheckInTime   sql.NullTime
	CreatedAt     time.Time
	UpdatedAt     time.Time
}

func (q *Queries) CreateVehicle(ctx context.Context, arg CreateVehicleParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createVehicle,
		arg.DriverID,
		arg.LicenseNumber,
		arg.CardNumber,
		arg.Occupants,
		arg.Model,
		arg.SecurityNotes,
		arg.ParkingID,
		arg.ServiceID,
		arg.CheckedInBy,
		arg.IsCheckedOut,
		arg.CheckInTime,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
}

const deleteDriverById = `-- name: DeleteDriverById :exec
DELETE FROM driver WHERE id = $1
`

func (q *Queries) DeleteDriverById(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteDriverById, id)
	return err
}

const deleteVehicleById = `-- name: DeleteVehicleById :exec
DELETE FROM vehicle WHERE id = $1
`

func (q *Queries) DeleteVehicleById(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteVehicleById, id)
	return err
}

const getDriverById = `-- name: GetDriverById :one
SELECT id, fullname, phone_number, email, created_at, updated_at FROM driver WHERE id = $1
`

func (q *Queries) GetDriverById(ctx context.Context, id int32) (Driver, error) {
	row := q.db.QueryRowContext(ctx, getDriverById, id)
	var i Driver
	err := row.Scan(
		&i.ID,
		&i.Fullname,
		&i.PhoneNumber,
		&i.Email,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getDriverByName = `-- name: GetDriverByName :one
SELECT id, fullname, phone_number, email, created_at, updated_at FROM driver WHERE fullname LIKE $1
`

func (q *Queries) GetDriverByName(ctx context.Context, fullname string) (Driver, error) {
	row := q.db.QueryRowContext(ctx, getDriverByName, fullname)
	var i Driver
	err := row.Scan(
		&i.ID,
		&i.Fullname,
		&i.PhoneNumber,
		&i.Email,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getVehicleById = `-- name: GetVehicleById :one
SELECT vehicle.id, driver_id, license_number, model, security_notes, parking_id, service_id, is_checked_out, check_in_time, check_out_time, vehicle.created_at, vehicle.updated_at, card_number, checked_in_by, checked_out_by, occupants, driver.id, fullname, phone_number, email, driver.created_at, driver.updated_at FROM vehicle JOIN driver ON vehicle.driver_id = driver.id  WHERE vehicle.id = $1
`

type GetVehicleByIdRow struct {
	ID            int32
	DriverID      int32
	LicenseNumber string
	Model         sql.NullString
	SecurityNotes sql.NullString
	ParkingID     int32
	ServiceID     int32
	IsCheckedOut  sql.NullBool
	CheckInTime   sql.NullTime
	CheckOutTime  sql.NullTime
	CreatedAt     time.Time
	UpdatedAt     time.Time
	CardNumber    sql.NullString
	CheckedInBy   int32
	CheckedOutBy  int32
	Occupants     sql.NullString
	ID_2          int32
	Fullname      string
	PhoneNumber   string
	Email         sql.NullString
	CreatedAt_2   time.Time
	UpdatedAt_2   time.Time
}

func (q *Queries) GetVehicleById(ctx context.Context, id int32) (GetVehicleByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getVehicleById, id)
	var i GetVehicleByIdRow
	err := row.Scan(
		&i.ID,
		&i.DriverID,
		&i.LicenseNumber,
		&i.Model,
		&i.SecurityNotes,
		&i.ParkingID,
		&i.ServiceID,
		&i.IsCheckedOut,
		&i.CheckInTime,
		&i.CheckOutTime,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CardNumber,
		&i.CheckedInBy,
		&i.CheckedOutBy,
		&i.Occupants,
		&i.ID_2,
		&i.Fullname,
		&i.PhoneNumber,
		&i.Email,
		&i.CreatedAt_2,
		&i.UpdatedAt_2,
	)
	return i, err
}

const getVehiclesByDriver = `-- name: GetVehiclesByDriver :many
SELECT vehicle.id, driver_id, license_number, model, security_notes, parking_id, service_id, is_checked_out, check_in_time, check_out_time, vehicle.created_at, vehicle.updated_at, card_number, checked_in_by, checked_out_by, occupants, driver.id, fullname, phone_number, email, driver.created_at, driver.updated_at FROM vehicle JOIN driver ON vehicle.driver_id = driver.id  WHERE vehicle.driver_id = $1
`

type GetVehiclesByDriverRow struct {
	ID            int32
	DriverID      int32
	LicenseNumber string
	Model         sql.NullString
	SecurityNotes sql.NullString
	ParkingID     int32
	ServiceID     int32
	IsCheckedOut  sql.NullBool
	CheckInTime   sql.NullTime
	CheckOutTime  sql.NullTime
	CreatedAt     time.Time
	UpdatedAt     time.Time
	CardNumber    sql.NullString
	CheckedInBy   int32
	CheckedOutBy  int32
	Occupants     sql.NullString
	ID_2          int32
	Fullname      string
	PhoneNumber   string
	Email         sql.NullString
	CreatedAt_2   time.Time
	UpdatedAt_2   time.Time
}

func (q *Queries) GetVehiclesByDriver(ctx context.Context, driverID int32) ([]GetVehiclesByDriverRow, error) {
	rows, err := q.db.QueryContext(ctx, getVehiclesByDriver, driverID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetVehiclesByDriverRow
	for rows.Next() {
		var i GetVehiclesByDriverRow
		if err := rows.Scan(
			&i.ID,
			&i.DriverID,
			&i.LicenseNumber,
			&i.Model,
			&i.SecurityNotes,
			&i.ParkingID,
			&i.ServiceID,
			&i.IsCheckedOut,
			&i.CheckInTime,
			&i.CheckOutTime,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CardNumber,
			&i.CheckedInBy,
			&i.CheckedOutBy,
			&i.Occupants,
			&i.ID_2,
			&i.Fullname,
			&i.PhoneNumber,
			&i.Email,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVehiclesByLicense = `-- name: GetVehiclesByLicense :many
SELECT vehicle.id, driver_id, license_number, model, security_notes, parking_id, service_id, is_checked_out, check_in_time, check_out_time, vehicle.created_at, vehicle.updated_at, card_number, checked_in_by, checked_out_by, occupants, driver.id, fullname, phone_number, email, driver.created_at, driver.updated_at FROM vehicle JOIN driver ON vehicle.driver_id = driver.id  WHERE vehicle.license_number = $1
`

type GetVehiclesByLicenseRow struct {
	ID            int32
	DriverID      int32
	LicenseNumber string
	Model         sql.NullString
	SecurityNotes sql.NullString
	ParkingID     int32
	ServiceID     int32
	IsCheckedOut  sql.NullBool
	CheckInTime   sql.NullTime
	CheckOutTime  sql.NullTime
	CreatedAt     time.Time
	UpdatedAt     time.Time
	CardNumber    sql.NullString
	CheckedInBy   int32
	CheckedOutBy  int32
	Occupants     sql.NullString
	ID_2          int32
	Fullname      string
	PhoneNumber   string
	Email         sql.NullString
	CreatedAt_2   time.Time
	UpdatedAt_2   time.Time
}

func (q *Queries) GetVehiclesByLicense(ctx context.Context, licenseNumber string) ([]GetVehiclesByLicenseRow, error) {
	rows, err := q.db.QueryContext(ctx, getVehiclesByLicense, licenseNumber)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetVehiclesByLicenseRow
	for rows.Next() {
		var i GetVehiclesByLicenseRow
		if err := rows.Scan(
			&i.ID,
			&i.DriverID,
			&i.LicenseNumber,
			&i.Model,
			&i.SecurityNotes,
			&i.ParkingID,
			&i.ServiceID,
			&i.IsCheckedOut,
			&i.CheckInTime,
			&i.CheckOutTime,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CardNumber,
			&i.CheckedInBy,
			&i.CheckedOutBy,
			&i.Occupants,
			&i.ID_2,
			&i.Fullname,
			&i.PhoneNumber,
			&i.Email,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVehiclesByParking = `-- name: GetVehiclesByParking :many
SELECT vehicle.id, driver_id, license_number, model, security_notes, parking_id, service_id, is_checked_out, check_in_time, check_out_time, vehicle.created_at, vehicle.updated_at, card_number, checked_in_by, checked_out_by, occupants, driver.id, fullname, phone_number, email, driver.created_at, driver.updated_at FROM vehicle JOIN driver ON vehicle.driver_id = driver.id  WHERE vehicle.parking_id = $1
`

type GetVehiclesByParkingRow struct {
	ID            int32
	DriverID      int32
	LicenseNumber string
	Model         sql.NullString
	SecurityNotes sql.NullString
	ParkingID     int32
	ServiceID     int32
	IsCheckedOut  sql.NullBool
	CheckInTime   sql.NullTime
	CheckOutTime  sql.NullTime
	CreatedAt     time.Time
	UpdatedAt     time.Time
	CardNumber    sql.NullString
	CheckedInBy   int32
	CheckedOutBy  int32
	Occupants     sql.NullString
	ID_2          int32
	Fullname      string
	PhoneNumber   string
	Email         sql.NullString
	CreatedAt_2   time.Time
	UpdatedAt_2   time.Time
}

func (q *Queries) GetVehiclesByParking(ctx context.Context, parkingID int32) ([]GetVehiclesByParkingRow, error) {
	rows, err := q.db.QueryContext(ctx, getVehiclesByParking, parkingID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetVehiclesByParkingRow
	for rows.Next() {
		var i GetVehiclesByParkingRow
		if err := rows.Scan(
			&i.ID,
			&i.DriverID,
			&i.LicenseNumber,
			&i.Model,
			&i.SecurityNotes,
			&i.ParkingID,
			&i.ServiceID,
			&i.IsCheckedOut,
			&i.CheckInTime,
			&i.CheckOutTime,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CardNumber,
			&i.CheckedInBy,
			&i.CheckedOutBy,
			&i.Occupants,
			&i.ID_2,
			&i.Fullname,
			&i.PhoneNumber,
			&i.Email,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVehiclesByService = `-- name: GetVehiclesByService :many
SELECT
  vehicle.id, vehicle.driver_id, vehicle.license_number, vehicle.model, vehicle.security_notes, vehicle.parking_id, vehicle.service_id, vehicle.is_checked_out, vehicle.check_in_time, vehicle.check_out_time, vehicle.created_at, vehicle.updated_at, vehicle.card_number, vehicle.checked_in_by, vehicle.checked_out_by, vehicle.occupants,                                -- All vehicle fields
  driver.id, driver.fullname, driver.phone_number, driver.email, driver.created_at, driver.updated_at,                                 -- All driver fields
  checkin_member.codename AS checked_in_by_codename,     -- Codename of check-in team member
  checkout_member.codename AS checked_out_by_codename,   -- Codename of check-out team member
  parkingstation.codename AS parked_at     -- Codename of the parking station
FROM vehicle
JOIN driver ON vehicle.driver_id = driver.id
JOIN team_member AS checkin_member ON checkin_member.id = vehicle.checked_in_by
JOIN team_member AS checkout_member ON checkout_member.id = vehicle.checked_out_by
JOIN parkingstation ON parkingstation.id = vehicle.parking_id
WHERE vehicle.service_id = $1
`

type GetVehiclesByServiceRow struct {
	ID                   int32
	DriverID             int32
	LicenseNumber        string
	Model                sql.NullString
	SecurityNotes        sql.NullString
	ParkingID            int32
	ServiceID            int32
	IsCheckedOut         sql.NullBool
	CheckInTime          sql.NullTime
	CheckOutTime         sql.NullTime
	CreatedAt            time.Time
	UpdatedAt            time.Time
	CardNumber           sql.NullString
	CheckedInBy          int32
	CheckedOutBy         int32
	Occupants            sql.NullString
	ID_2                 int32
	Fullname             string
	PhoneNumber          string
	Email                sql.NullString
	CreatedAt_2          time.Time
	UpdatedAt_2          time.Time
	CheckedInByCodename  string
	CheckedOutByCodename string
	ParkedAt             string
}

func (q *Queries) GetVehiclesByService(ctx context.Context, serviceID int32) ([]GetVehiclesByServiceRow, error) {
	rows, err := q.db.QueryContext(ctx, getVehiclesByService, serviceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetVehiclesByServiceRow
	for rows.Next() {
		var i GetVehiclesByServiceRow
		if err := rows.Scan(
			&i.ID,
			&i.DriverID,
			&i.LicenseNumber,
			&i.Model,
			&i.SecurityNotes,
			&i.ParkingID,
			&i.ServiceID,
			&i.IsCheckedOut,
			&i.CheckInTime,
			&i.CheckOutTime,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CardNumber,
			&i.CheckedInBy,
			&i.CheckedOutBy,
			&i.Occupants,
			&i.ID_2,
			&i.Fullname,
			&i.PhoneNumber,
			&i.Email,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
			&i.CheckedInByCodename,
			&i.CheckedOutByCodename,
			&i.ParkedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVehiclesExisting = `-- name: GetVehiclesExisting :many
SELECT id, driver_id, license_number, model, security_notes, parking_id, service_id, is_checked_out, check_in_time, check_out_time, created_at, updated_at, card_number, checked_in_by, checked_out_by, occupants FROM vehicle WHERE license_number = $1 AND service_id = $2
`

type GetVehiclesExistingParams struct {
	LicenseNumber string
	ServiceID     int32
}

func (q *Queries) GetVehiclesExisting(ctx context.Context, arg GetVehiclesExistingParams) ([]Vehicle, error) {
	rows, err := q.db.QueryContext(ctx, getVehiclesExisting, arg.LicenseNumber, arg.ServiceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Vehicle
	for rows.Next() {
		var i Vehicle
		if err := rows.Scan(
			&i.ID,
			&i.DriverID,
			&i.LicenseNumber,
			&i.Model,
			&i.SecurityNotes,
			&i.ParkingID,
			&i.ServiceID,
			&i.IsCheckedOut,
			&i.CheckInTime,
			&i.CheckOutTime,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CardNumber,
			&i.CheckedInBy,
			&i.CheckedOutBy,
			&i.Occupants,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const groupVehiclesByParking = `-- name: GroupVehiclesByParking :many
SELECT COUNT(vehicle.ID), parkingstation.name, parkingstation.codename
FROM vehicle
JOIN driver ON vehicle.driver_id = driver.id
JOIN parkingstation ON vehicle.parking_id = parkingstation.id
GROUP BY(parkingstation.id)
`

type GroupVehiclesByParkingRow struct {
	Count    int64
	Name     string
	Codename string
}

func (q *Queries) GroupVehiclesByParking(ctx context.Context) ([]GroupVehiclesByParkingRow, error) {
	rows, err := q.db.QueryContext(ctx, groupVehiclesByParking)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GroupVehiclesByParkingRow
	for rows.Next() {
		var i GroupVehiclesByParkingRow
		if err := rows.Scan(&i.Count, &i.Name, &i.Codename); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const groupVehiclesByParkingAndService = `-- name: GroupVehiclesByParkingAndService :many
SELECT COUNT(vehicle.ID), parkingstation.name, parkingstation.codename
FROM vehicle
JOIN driver ON vehicle.driver_id = driver.id
JOIN parkingstation ON vehicle.parking_id = parkingstation.id
WHERE vehicle.service_id = $1
GROUP BY parkingstation.id
`

type GroupVehiclesByParkingAndServiceRow struct {
	Count    int64
	Name     string
	Codename string
}

func (q *Queries) GroupVehiclesByParkingAndService(ctx context.Context, serviceID int32) ([]GroupVehiclesByParkingAndServiceRow, error) {
	rows, err := q.db.QueryContext(ctx, groupVehiclesByParkingAndService, serviceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GroupVehiclesByParkingAndServiceRow
	for rows.Next() {
		var i GroupVehiclesByParkingAndServiceRow
		if err := rows.Scan(&i.Count, &i.Name, &i.Codename); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDriver = `-- name: ListDriver :many
SELECT id, fullname, phone_number, email, created_at, updated_at FROM driver ORDER BY ID DESC
`

func (q *Queries) ListDriver(ctx context.Context) ([]Driver, error) {
	rows, err := q.db.QueryContext(ctx, listDriver)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Driver
	for rows.Next() {
		var i Driver
		if err := rows.Scan(
			&i.ID,
			&i.Fullname,
			&i.PhoneNumber,
			&i.Email,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVehicle = `-- name: ListVehicle :many
SELECT vehicle.id, driver_id, license_number, model, security_notes, parking_id, service_id, is_checked_out, check_in_time, check_out_time, vehicle.created_at, vehicle.updated_at, card_number, checked_in_by, checked_out_by, occupants, driver.id, fullname, phone_number, email, driver.created_at, driver.updated_at FROM vehicle JOIN driver ON vehicle.driver_id = driver.id ORDER BY vehicle.ID DESC
`

type ListVehicleRow struct {
	ID            int32
	DriverID      int32
	LicenseNumber string
	Model         sql.NullString
	SecurityNotes sql.NullString
	ParkingID     int32
	ServiceID     int32
	IsCheckedOut  sql.NullBool
	CheckInTime   sql.NullTime
	CheckOutTime  sql.NullTime
	CreatedAt     time.Time
	UpdatedAt     time.Time
	CardNumber    sql.NullString
	CheckedInBy   int32
	CheckedOutBy  int32
	Occupants     sql.NullString
	ID_2          int32
	Fullname      string
	PhoneNumber   string
	Email         sql.NullString
	CreatedAt_2   time.Time
	UpdatedAt_2   time.Time
}

func (q *Queries) ListVehicle(ctx context.Context) ([]ListVehicleRow, error) {
	rows, err := q.db.QueryContext(ctx, listVehicle)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListVehicleRow
	for rows.Next() {
		var i ListVehicleRow
		if err := rows.Scan(
			&i.ID,
			&i.DriverID,
			&i.LicenseNumber,
			&i.Model,
			&i.SecurityNotes,
			&i.ParkingID,
			&i.ServiceID,
			&i.IsCheckedOut,
			&i.CheckInTime,
			&i.CheckOutTime,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CardNumber,
			&i.CheckedInBy,
			&i.CheckedOutBy,
			&i.Occupants,
			&i.ID_2,
			&i.Fullname,
			&i.PhoneNumber,
			&i.Email,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchVehicle = `-- name: SearchVehicle :many
SELECT vehicle.id, driver_id, license_number, model, security_notes, parking_id, service_id, is_checked_out, check_in_time, check_out_time, vehicle.created_at, vehicle.updated_at, card_number, checked_in_by, checked_out_by, occupants, driver.id, fullname, phone_number, email, driver.created_at, driver.updated_at FROM vehicle JOIN driver ON vehicle.driver_id = driver.id
WHERE vehicle.license_number LIKE '%'||$1||'%' OR driver.fullname LIKE '%'||$1||'%' OR vehicle.card_number LIKE '%'||$1||'%'
ORDER BY vehicle.created_at DESC
`

type SearchVehicleRow struct {
	ID            int32
	DriverID      int32
	LicenseNumber string
	Model         sql.NullString
	SecurityNotes sql.NullString
	ParkingID     int32
	ServiceID     int32
	IsCheckedOut  sql.NullBool
	CheckInTime   sql.NullTime
	CheckOutTime  sql.NullTime
	CreatedAt     time.Time
	UpdatedAt     time.Time
	CardNumber    sql.NullString
	CheckedInBy   int32
	CheckedOutBy  int32
	Occupants     sql.NullString
	ID_2          int32
	Fullname      string
	PhoneNumber   string
	Email         sql.NullString
	CreatedAt_2   time.Time
	UpdatedAt_2   time.Time
}

func (q *Queries) SearchVehicle(ctx context.Context, dollar_1 sql.NullString) ([]SearchVehicleRow, error) {
	rows, err := q.db.QueryContext(ctx, searchVehicle, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchVehicleRow
	for rows.Next() {
		var i SearchVehicleRow
		if err := rows.Scan(
			&i.ID,
			&i.DriverID,
			&i.LicenseNumber,
			&i.Model,
			&i.SecurityNotes,
			&i.ParkingID,
			&i.ServiceID,
			&i.IsCheckedOut,
			&i.CheckInTime,
			&i.CheckOutTime,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CardNumber,
			&i.CheckedInBy,
			&i.CheckedOutBy,
			&i.Occupants,
			&i.ID_2,
			&i.Fullname,
			&i.PhoneNumber,
			&i.Email,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateDriver = `-- name: UpdateDriver :exec
UPDATE driver
SET fullname = $2, phone_number = $3,
    email = $4, updated_at = $5
WHERE id = $1
`

type UpdateDriverParams struct {
	ID          int32
	Fullname    string
	PhoneNumber string
	Email       sql.NullString
	UpdatedAt   time.Time
}

func (q *Queries) UpdateDriver(ctx context.Context, arg UpdateDriverParams) error {
	_, err := q.db.ExecContext(ctx, updateDriver,
		arg.ID,
		arg.Fullname,
		arg.PhoneNumber,
		arg.Email,
		arg.UpdatedAt,
	)
	return err
}

const updateVehicle = `-- name: UpdateVehicle :exec
UPDATE vehicle
SET driver_id = $2, license_number = $3,
    model = $4, security_notes = $5,
    updated_at = $6
WHERE id = $1
`

type UpdateVehicleParams struct {
	ID            int32
	DriverID      int32
	LicenseNumber string
	Model         sql.NullString
	SecurityNotes sql.NullString
	UpdatedAt     time.Time
}

func (q *Queries) UpdateVehicle(ctx context.Context, arg UpdateVehicleParams) error {
	_, err := q.db.ExecContext(ctx, updateVehicle,
		arg.ID,
		arg.DriverID,
		arg.LicenseNumber,
		arg.Model,
		arg.SecurityNotes,
		arg.UpdatedAt,
	)
	return err
}
